#!/usr/bin/env python3
"""
Vulnerability Database and Management System
Comprehensive CVE database and vulnerability management
"""

import json
import logging
import sqlite3
import os
from datetime import datetime, timedelta
import requests
import threading
import time

class VulnerabilityDatabase:
    def __init__(self, db_path="vulnerabilities.db"):
        self.db_path = db_path
        self.init_database()
        self.cve_cache = {}
        self.last_update = self.get_last_update()
        
    def init_database(self):
        """Initialize the vulnerability database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Enable foreign key support
            cursor.execute("PRAGMA foreign_keys = ON")
            
            # Create tables
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    cve_id TEXT UNIQUE NOT NULL,
                    title TEXT,
                    description TEXT,
                    severity TEXT,
                    cvss_score REAL,
                    affected_software TEXT,
                    affected_versions TEXT,
                    patch_available BOOLEAN,
                    exploit_available BOOLEAN,
                    created_date TEXT,
                    modified_date TEXT,
                    reference_urls TEXT
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS exploits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    cve_id TEXT,
                    exploit_type TEXT,
                    exploit_code TEXT,
                    reliability TEXT,
                    author TEXT,
                    created_date TEXT
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scan_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    scan_id TEXT,
                    target TEXT,
                    scan_type TEXT,
                    vulnerabilities_found INTEGER,
                    critical_count INTEGER,
                    high_count INTEGER,
                    medium_count INTEGER,
                    low_count INTEGER,
                    scan_date TEXT,
                    scan_data TEXT
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS remediation_status (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    cve_id TEXT,
                    target TEXT,
                    status TEXT,
                    assigned_to TEXT,
                    due_date TEXT,
                    notes TEXT,
                    created_date TEXT,
                    updated_date TEXT
                )
            ''')
            
            conn.commit()
            conn.close()
            
            # Populate with initial data
            self.populate_initial_data()
            
        except Exception as e:
            logging.error(f"Error initializing database: {e}")
    
    def populate_initial_data(self):
        """Populate database with initial vulnerability data"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Check if data already exists
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
            count = cursor.fetchone()[0]
            
            if count == 0:
                initial_vulns = self.get_initial_vulnerabilities()
                for vuln in initial_vulns:
                    cursor.execute('''
                        INSERT OR IGNORE INTO vulnerabilities 
                        (cve_id, title, description, severity, cvss_score, affected_software, 
                         affected_versions, patch_available, exploit_available, created_date, reference_urls)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        vuln['cve_id'], vuln['title'], vuln['description'], vuln['severity'],
                        vuln['cvss_score'], vuln['affected_software'], vuln['affected_versions'],
                        vuln['patch_available'], vuln['exploit_available'], vuln['created_date'],
                        vuln['references']
                    ))
                
                conn.commit()
                logging.info(f"Populated database with {len(initial_vulns)} initial vulnerabilities")
            
            conn.close()
            
        except Exception as e:
            logging.error(f"Error populating initial data: {e}")
    
    def get_initial_vulnerabilities(self):
        """Get initial set of important vulnerabilities"""
        return [
            {
                'cve_id': 'CVE-2021-4034',
                'title': 'PwnKit - Local Privilege Escalation in polkit',
                'description': 'A local privilege escalation vulnerability was found in polkit\'s pkexec utility.',
                'severity': 'Critical',
                'cvss_score': 7.8,
                'affected_software': 'polkit',
                'affected_versions': '0.113-0.119',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2022-01-25',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2021-4034'
            },
            {
                'cve_id': 'CVE-2021-34527',
                'title': 'PrintNightmare - Windows Print Spooler RCE',
                'description': 'Windows Print Spooler Remote Code Execution Vulnerability',
                'severity': 'Critical',
                'cvss_score': 8.8,
                'affected_software': 'Windows Print Spooler',
                'affected_versions': 'Windows 10, Windows Server 2019, Windows Server 2016',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2021-07-01',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2021-34527'
            },
            {
                'cve_id': 'CVE-2021-36934',
                'title': 'HiveNightmare/SeriousSAM - Windows SAM Access',
                'description': 'Windows Elevation of Privilege Vulnerability in SAM database',
                'severity': 'High',
                'cvss_score': 7.8,
                'affected_software': 'Windows',
                'affected_versions': 'Windows 10 1809+, Windows 11',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2021-07-20',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2021-36934'
            },
            {
                'cve_id': 'CVE-2020-1472',
                'title': 'Zerologon - Netlogon Elevation of Privilege',
                'description': 'An elevation of privilege vulnerability exists when an attacker establishes a vulnerable Netlogon secure channel connection',
                'severity': 'Critical',
                'cvss_score': 10.0,
                'affected_software': 'Windows Active Directory',
                'affected_versions': 'Windows Server 2008-2019',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2020-08-11',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2020-1472'
            },
            {
                'cve_id': 'CVE-2021-3156',
                'title': 'Baron Samedit - Sudo Heap Overflow',
                'description': 'Heap-based buffer overflow in sudo when shell is not listed in /etc/shells',
                'severity': 'Critical',
                'cvss_score': 7.8,
                'affected_software': 'sudo',
                'affected_versions': '1.8.2-1.8.31p2, 1.9.0-1.9.5p1',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2021-01-26',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2021-3156'
            },
            {
                'cve_id': 'CVE-2017-0144',
                'title': 'EternalBlue - SMB Remote Code Execution',
                'description': 'Microsoft SMBv1 Remote Code Execution Vulnerability',
                'severity': 'Critical',
                'cvss_score': 8.1,
                'affected_software': 'Windows SMB',
                'affected_versions': 'Windows Vista-Windows 10, Windows Server 2008-2016',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2017-03-14',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2017-0144'
            },
            {
                'cve_id': 'CVE-2016-5195',
                'title': 'Dirty COW - Linux Kernel Race Condition',
                'description': 'Race condition in mm/gup.c in the Linux kernel allows privilege escalation',
                'severity': 'High',
                'cvss_score': 7.8,
                'affected_software': 'Linux Kernel',
                'affected_versions': '2.6.22 - 4.8.3',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2016-10-19',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2016-5195'
            },
            {
                'cve_id': 'CVE-2019-0708',
                'title': 'BlueKeep - RDP Remote Code Execution',
                'description': 'Remote Code Execution vulnerability in Remote Desktop Services',
                'severity': 'Critical',
                'cvss_score': 9.8,
                'affected_software': 'Windows Remote Desktop',
                'affected_versions': 'Windows 7, Windows Server 2008 R2, Windows Server 2008',
                'patch_available': True,
                'exploit_available': True,
                'created_date': '2019-05-14',
                'references': 'https://nvd.nist.gov/vuln/detail/CVE-2019-0708'
            }
        ]
    
    def store_scan_results(self, scan_id, target, scan_type, results):
        """Store vulnerability scan results"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Count vulnerabilities by severity
            severity_counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
            vulnerabilities = results.get('vulnerabilities', [])
            
            for vuln in vulnerabilities:
                severity = vuln.get('severity', 'Low')
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            cursor.execute('''
                INSERT INTO scan_results 
                (scan_id, target, scan_type, vulnerabilities_found, critical_count, 
                 high_count, medium_count, low_count, scan_date, scan_data)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                scan_id, target, scan_type, len(vulnerabilities),
                severity_counts['Critical'], severity_counts['High'],
                severity_counts['Medium'], severity_counts['Low'],
                datetime.now().isoformat(), json.dumps(results)
            ))
            
            conn.commit()
            conn.close()
            
            logging.info(f"Stored scan results for {target}: {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            logging.error(f"Error storing scan results: {e}")
    
    def get_vulnerability_by_cve(self, cve_id):
        """Get vulnerability information by CVE ID"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT * FROM vulnerabilities WHERE cve_id = ?
            ''', (cve_id,))
            
            result = cursor.fetchone()
            conn.close()
            
            if result:
                columns = [desc[0] for desc in cursor.description]
                return dict(zip(columns, result))
            
            return None
            
        except Exception as e:
            logging.error(f"Error getting vulnerability {cve_id}: {e}")
            return None
    
    def search_vulnerabilities(self, software=None, severity=None, exploit_available=None):
        """Search vulnerabilities by criteria"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            query = "SELECT * FROM vulnerabilities WHERE 1=1"
            params = []
            
            if software:
                query += " AND affected_software LIKE ?"
                params.append(f"%{software}%")
            
            if severity:
                query += " AND severity = ?"
                params.append(severity)
            
            if exploit_available is not None:
                query += " AND exploit_available = ?"
                params.append(exploit_available)
            
            query += " ORDER BY cvss_score DESC"
            
            cursor.execute(query, params)
            results = cursor.fetchall()
            conn.close()
            
            columns = [desc[0] for desc in cursor.description]
            return [dict(zip(columns, row)) for row in results]
            
        except Exception as e:
            logging.error(f"Error searching vulnerabilities: {e}")
            return []
    
    def get_scan_history(self, target=None, days=30):
        """Get scan history for a target"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cutoff_date = (datetime.now() - timedelta(days=days)).isoformat()
            
            if target:
                cursor.execute('''
                    SELECT * FROM scan_results 
                    WHERE target = ? AND scan_date >= ?
                    ORDER BY scan_date DESC
                ''', (target, cutoff_date))
            else:
                cursor.execute('''
                    SELECT * FROM scan_results 
                    WHERE scan_date >= ?
                    ORDER BY scan_date DESC
                ''', (cutoff_date,))
            
            results = cursor.fetchall()
            conn.close()
            
            columns = [desc[0] for desc in cursor.description]
            return [dict(zip(columns, row)) for row in results]
            
        except Exception as e:
            logging.error(f"Error getting scan history: {e}")
            return []
    
    def create_remediation_ticket(self, cve_id, target, assigned_to=None, due_date=None, notes=None):
        """Create a remediation ticket for a vulnerability"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO remediation_status 
                (cve_id, target, status, assigned_to, due_date, notes, created_date, updated_date)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                cve_id, target, 'Open', assigned_to, due_date, notes,
                datetime.now().isoformat(), datetime.now().isoformat()
            ))
            
            conn.commit()
            conn.close()
            
            logging.info(f"Created remediation ticket for {cve_id} on {target}")
            
        except Exception as e:
            logging.error(f"Error creating remediation ticket: {e}")
    
    def update_remediation_status(self, ticket_id, status, notes=None):
        """Update remediation ticket status"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if notes:
                cursor.execute('''
                    UPDATE remediation_status 
                    SET status = ?, notes = ?, updated_date = ?
                    WHERE id = ?
                ''', (status, notes, datetime.now().isoformat(), ticket_id))
            else:
                cursor.execute('''
                    UPDATE remediation_status 
                    SET status = ?, updated_date = ?
                    WHERE id = ?
                ''', (status, datetime.now().isoformat(), ticket_id))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logging.error(f"Error updating remediation status: {e}")
    
    def get_remediation_tickets(self, status=None):
        """Get remediation tickets"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if status:
                cursor.execute('''
                    SELECT r.*, v.title, v.severity, v.cvss_score
                    FROM remediation_status r
                    JOIN vulnerabilities v ON r.cve_id = v.cve_id
                    WHERE r.status = ?
                    ORDER BY v.cvss_score DESC
                ''', (status,))
            else:
                cursor.execute('''
                    SELECT r.*, v.title, v.severity, v.cvss_score
                    FROM remediation_status r
                    JOIN vulnerabilities v ON r.cve_id = v.cve_id
                    ORDER BY v.cvss_score DESC
                ''')
            
            results = cursor.fetchall()
            conn.close()
            
            columns = [desc[0] for desc in cursor.description]
            return [dict(zip(columns, row)) for row in results]
            
        except Exception as e:
            logging.error(f"Error getting remediation tickets: {e}")
            return []
    
    def generate_vulnerability_report(self, target=None, days=7):
        """Generate comprehensive vulnerability report"""
        try:
            report = {
                'generated_date': datetime.now().isoformat(),
                'target': target or 'All Targets',
                'period_days': days,
                'summary': {},
                'top_vulnerabilities': [],
                'remediation_status': {},
                'scan_history': []
            }
            
            # Get scan history
            scan_history = self.get_scan_history(target, days)
            report['scan_history'] = scan_history
            
            # Calculate summary statistics
            total_vulns = sum(scan['vulnerabilities_found'] for scan in scan_history)
            total_critical = sum(scan['critical_count'] for scan in scan_history)
            total_high = sum(scan['high_count'] for scan in scan_history)
            total_medium = sum(scan['medium_count'] for scan in scan_history)
            total_low = sum(scan['low_count'] for scan in scan_history)
            
            report['summary'] = {
                'total_scans': len(scan_history),
                'total_vulnerabilities': total_vulns,
                'critical_vulnerabilities': total_critical,
                'high_vulnerabilities': total_high,
                'medium_vulnerabilities': total_medium,
                'low_vulnerabilities': total_low
            }
            
            # Get top vulnerabilities by CVSS score
            top_vulns = self.search_vulnerabilities()[:10]  # Top 10
            report['top_vulnerabilities'] = top_vulns
            
            # Get remediation status
            open_tickets = len(self.get_remediation_tickets('Open'))
            in_progress_tickets = len(self.get_remediation_tickets('In Progress'))
            resolved_tickets = len(self.get_remediation_tickets('Resolved'))
            
            report['remediation_status'] = {
                'open_tickets': open_tickets,
                'in_progress_tickets': in_progress_tickets,
                'resolved_tickets': resolved_tickets
            }
            
            return report
            
        except Exception as e:
            logging.error(f"Error generating vulnerability report: {e}")
            return None
    
    def update_vulnerability_database(self):
        """Update vulnerability database from external sources"""
        try:
            # This would typically fetch from NVD or other CVE databases
            # For now, we'll simulate an update
            logging.info("Updating vulnerability database...")
            
            # Update timestamp
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # You could add logic here to fetch from NVD API
            # For demonstration, we'll just update the timestamp
            
            conn.close()
            
            self.last_update = datetime.now().isoformat()
            logging.info("Vulnerability database updated successfully")
            
        except Exception as e:
            logging.error(f"Error updating vulnerability database: {e}")
    
    def get_last_update(self):
        """Get last database update timestamp"""
        try:
            if os.path.exists(f"{self.db_path}.timestamp"):
                with open(f"{self.db_path}.timestamp", 'r') as f:
                    return f.read().strip()
        except:
            pass
        return datetime.now().isoformat()
    
    def get_database_stats(self):
        """Get database statistics"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            stats = {}
            
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
            stats['total_vulnerabilities'] = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM scan_results")
            stats['total_scans'] = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM remediation_status")
            stats['total_tickets'] = cursor.fetchone()[0]
            
            cursor.execute("SELECT severity, COUNT(*) FROM vulnerabilities GROUP BY severity")
            severity_breakdown = dict(cursor.fetchall())
            stats['severity_breakdown'] = severity_breakdown
            
            conn.close()
            
            stats['last_update'] = self.last_update
            
            return stats
            
        except Exception as e:
            logging.error(f"Error getting database stats: {e}")
            return {}

# Global database instance
vuln_db = VulnerabilityDatabase()

def get_vulnerability_database():
    """Get the global vulnerability database instance"""
    return vuln_db

if __name__ == "__main__":
    # Test the database
    db = VulnerabilityDatabase("test_vulns.db")
    
    # Test search
    critical_vulns = db.search_vulnerabilities(severity='Critical')
    print(f"Found {len(critical_vulns)} critical vulnerabilities")
    
    # Test report generation
    report = db.generate_vulnerability_report()
    print(json.dumps(report, indent=2))
