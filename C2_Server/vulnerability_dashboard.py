#!/usr/bin/env python3
"""
Vulnerability Assessment Dashboard Module
Provides comprehensive vulnerability management and dashboard capabilities
"""

import json
import logging
from datetime import datetime, timedelta
from collections import defaultdict, Counter
import threading
import time

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

class VulnerabilityDashboard:
    def __init__(self):
        self.vulnerabilities = {}
        self.agents = {}
        self.scans = {}
        self.reports = {}
        self.dashboard_data = {}
        self.risk_scores = {}
        self.vulnerability_stats = defaultdict(int)
        self.last_update = datetime.now()
        
        # Initialize dashboard data
        self.update_dashboard_data()
        
    def process_vulnerability_data(self, agent_id, data):
        """
        Process vulnerability data from agents
        
        Args:
            agent_id (str): Agent identifier
            data (dict): Vulnerability data from agent
            
        Returns:
            dict: Processing results
        """
        try:
            logging.info(f"Processing vulnerability data from agent {agent_id}")
            
            # Store agent data
            if agent_id not in self.agents:
                self.agents[agent_id] = {
                    'id': agent_id,
                    'first_seen': datetime.now().isoformat(),
                    'last_seen': datetime.now().isoformat(),
                    'vulnerabilities': [],
                    'scans': [],
                    'risk_score': 0
                }
            
            self.agents[agent_id]['last_seen'] = datetime.now().isoformat()
            
            # Process vulnerability data
            if 'vulnerabilities' in data:
                for vuln in data['vulnerabilities']:
                    vuln_id = f"{agent_id}_{vuln.get('type', 'unknown')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                    
                    # Add metadata
                    vuln['id'] = vuln_id
                    vuln['agent_id'] = agent_id
                    vuln['discovered_at'] = datetime.now().isoformat()
                    vuln['status'] = 'new'
                    
                    # Store vulnerability
                    self.vulnerabilities[vuln_id] = vuln
                    self.agents[agent_id]['vulnerabilities'].append(vuln_id)
                    
                    # Update statistics
                    severity = vuln.get('severity', 'Unknown')
                    self.vulnerability_stats[severity] += 1
            
            # Process scan data
            if 'scan_type' in data:
                scan_id = f"{agent_id}_{data['scan_type']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                scan_data = {
                    'id': scan_id,
                    'agent_id': agent_id,
                    'scan_type': data['scan_type'],
                    'timestamp': datetime.now().isoformat(),
                    'results': data,
                    'status': 'completed'
                }
                
                self.scans[scan_id] = scan_data
                self.agents[agent_id]['scans'].append(scan_id)
            
            # Update risk score
            self.update_agent_risk_score(agent_id)
            
            # Update dashboard data
            self.update_dashboard_data()
            
            logging.info(f"Successfully processed vulnerability data from agent {agent_id}")
            return {
                'status': 'success',
                'message': f'Processed {len(data.get("vulnerabilities", []))} vulnerabilities',
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            logging.error(f"Error processing vulnerability data from agent {agent_id}: {str(e)}")
            return {
                'status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def update_agent_risk_score(self, agent_id):
        """Update risk score for a specific agent"""
        try:
            if agent_id not in self.agents:
                return
            
            agent_vulns = [self.vulnerabilities[vuln_id] for vuln_id in self.agents[agent_id]['vulnerabilities'] 
                          if vuln_id in self.vulnerabilities]
            
            risk_score = self.calculate_risk_score(agent_vulns)
            self.agents[agent_id]['risk_score'] = risk_score
            self.risk_scores[agent_id] = risk_score
            
        except Exception as e:
            logging.error(f"Error updating risk score for agent {agent_id}: {str(e)}")
    
    def calculate_risk_score(self, vulnerabilities):
        """Calculate risk score based on vulnerabilities"""
        if not vulnerabilities:
            return 0
        
        severity_scores = {
            'Critical': 10,
            'High': 7,
            'Medium': 4,
            'Low': 1,
            'Info': 0
        }
        
        total_score = 0
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Low')
            total_score += severity_scores.get(severity, 1)
        
        # Normalize to 0-100 scale
        max_possible_score = len(vulnerabilities) * 10
        if max_possible_score > 0:
            risk_score = (total_score / max_possible_score) * 100
        else:
            risk_score = 0
        
        return round(risk_score, 2)
    
    def update_dashboard_data(self):
        """Update dashboard data for real-time display"""
        try:
            # Calculate overall statistics
            total_vulnerabilities = len(self.vulnerabilities)
            total_agents = len(self.agents)
            total_scans = len(self.scans)
            
            # Vulnerability severity breakdown
            severity_breakdown = dict(self.vulnerability_stats)
            
            # Agent status
            active_agents = 0
            for agent in self.agents.values():
                last_seen = datetime.fromisoformat(agent['last_seen'])
                if datetime.now() - last_seen < timedelta(minutes=5):
                    active_agents += 1
            
            # Recent vulnerabilities (last 24 hours)
            recent_vulns = []
            cutoff_time = datetime.now() - timedelta(hours=24)
            for vuln_id, vuln in self.vulnerabilities.items():
                discovered_at = datetime.fromisoformat(vuln['discovered_at'])
                if discovered_at > cutoff_time:
                    recent_vulns.append(vuln)
            
            # Top vulnerability types
            vuln_types = Counter([vuln.get('type', 'Unknown') for vuln in self.vulnerabilities.values()])
            top_vuln_types = vuln_types.most_common(5)
            
            # Risk score distribution
            risk_score_ranges = {
                'Critical (80-100)': 0,
                'High (60-79)': 0,
                'Medium (40-59)': 0,
                'Low (20-39)': 0,
                'Info (0-19)': 0
            }
            
            for risk_score in self.risk_scores.values():
                if risk_score >= 80:
                    risk_score_ranges['Critical (80-100)'] += 1
                elif risk_score >= 60:
                    risk_score_ranges['High (60-79)'] += 1
                elif risk_score >= 40:
                    risk_score_ranges['Medium (40-59)'] += 1
                elif risk_score >= 20:
                    risk_score_ranges['Low (20-39)'] += 1
                else:
                    risk_score_ranges['Info (0-19)'] += 1
            
            # Compile dashboard data
            self.dashboard_data = {
                'last_updated': datetime.now().isoformat(),
                'summary': {
                    'total_vulnerabilities': total_vulnerabilities,
                    'total_agents': total_agents,
                    'active_agents': active_agents,
                    'total_scans': total_scans,
                    'overall_risk_score': self.calculate_overall_risk_score()
                },
                'vulnerabilities': {
                    'severity_breakdown': severity_breakdown,
                    'recent_vulnerabilities': len(recent_vulns),
                    'top_vulnerability_types': top_vuln_types
                },
                'agents': {
                    'total_agents': total_agents,
                    'active_agents': active_agents,
                    'risk_score_distribution': risk_score_ranges
                },
                'scans': {
                    'total_scans': total_scans,
                    'recent_scans': len([s for s in self.scans.values() 
                                       if datetime.fromisoformat(s['timestamp']) > cutoff_time])
                }
            }
            
            self.last_update = datetime.now()
            
        except Exception as e:
            logging.error(f"Error updating dashboard data: {str(e)}")
    
    def calculate_overall_risk_score(self):
        """Calculate overall risk score for all agents"""
        if not self.risk_scores:
            return 0
        
        total_score = sum(self.risk_scores.values())
        return round(total_score / len(self.risk_scores), 2)
    
    def get_dashboard_data(self):
        """Get current dashboard data"""
        return self.dashboard_data
    
    def get_vulnerabilities(self, filters=None):
        """
        Get vulnerabilities with optional filtering
        
        Args:
            filters (dict): Optional filters (severity, agent_id, type, etc.)
            
        Returns:
            list: Filtered vulnerabilities
        """
        try:
            vulnerabilities = list(self.vulnerabilities.values())
            
            if filters:
                filtered_vulns = []
                for vuln in vulnerabilities:
                    include = True
                    
                    if 'severity' in filters and vuln.get('severity') != filters['severity']:
                        include = False
                    
                    if 'agent_id' in filters and vuln.get('agent_id') != filters['agent_id']:
                        include = False
                    
                    if 'type' in filters and vuln.get('type') != filters['type']:
                        include = False
                    
                    if 'status' in filters and vuln.get('status') != filters['status']:
                        include = False
                    
                    if include:
                        filtered_vulns.append(vuln)
                
                return filtered_vulns
            
            return vulnerabilities
            
        except Exception as e:
            logging.error(f"Error getting vulnerabilities: {str(e)}")
            return []
    
    def get_agent_summary(self, agent_id):
        """Get summary for a specific agent"""
        try:
            if agent_id not in self.agents:
                return None
            
            agent = self.agents[agent_id]
            agent_vulns = [self.vulnerabilities[vuln_id] for vuln_id in agent['vulnerabilities'] 
                          if vuln_id in self.vulnerabilities]
            
            severity_counts = Counter([vuln.get('severity', 'Unknown') for vuln in agent_vulns])
            
            return {
                'agent_id': agent_id,
                'first_seen': agent['first_seen'],
                'last_seen': agent['last_seen'],
                'risk_score': agent['risk_score'],
                'total_vulnerabilities': len(agent_vulns),
                'vulnerability_breakdown': dict(severity_counts),
                'recent_scans': len([s for s in self.scans.values() 
                                   if s['agent_id'] == agent_id and 
                                   datetime.fromisoformat(s['timestamp']) > datetime.now() - timedelta(hours=24)])
            }
            
        except Exception as e:
            logging.error(f"Error getting agent summary for {agent_id}: {str(e)}")
            return None
    
    def get_vulnerability_report(self, report_type='comprehensive'):
        """
        Generate vulnerability report
        
        Args:
            report_type (str): Type of report (comprehensive, executive, technical)
            
        Returns:
            dict: Generated report
        """
        try:
            report_id = f"report_{report_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            if report_type == 'executive':
                report = self.generate_executive_report()
            elif report_type == 'technical':
                report = self.generate_technical_report()
            else:
                report = self.generate_comprehensive_report()
            
            report['report_id'] = report_id
            report['generated_at'] = datetime.now().isoformat()
            report['report_type'] = report_type
            
            # Store report
            self.reports[report_id] = report
            
            return report
            
        except Exception as e:
            logging.error(f"Error generating vulnerability report: {str(e)}")
            return {
                'status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def generate_executive_report(self):
        """Generate executive summary report"""
        try:
            total_vulns = len(self.vulnerabilities)
            critical_vulns = len([v for v in self.vulnerabilities.values() if v.get('severity') == 'Critical'])
            high_vulns = len([v for v in self.vulnerabilities.values() if v.get('severity') == 'High'])
            
            overall_risk = self.calculate_overall_risk_score()
            
            return {
                'title': 'Executive Vulnerability Assessment Report',
                'summary': {
                    'total_vulnerabilities': total_vulns,
                    'critical_vulnerabilities': critical_vulns,
                    'high_vulnerabilities': high_vulns,
                    'overall_risk_score': overall_risk,
                    'total_agents': len(self.agents),
                    'active_agents': len([a for a in self.agents.values() 
                                        if datetime.fromisoformat(a['last_seen']) > datetime.now() - timedelta(minutes=5)])
                },
                'risk_assessment': {
                    'overall_risk_level': 'High' if overall_risk > 70 else 'Medium' if overall_risk > 40 else 'Low',
                    'critical_findings': critical_vulns,
                    'high_priority_findings': high_vulns
                },
                'recommendations': [
                    'Address critical vulnerabilities immediately',
                    'Implement security patches and updates',
                    'Review and update security policies',
                    'Conduct regular security assessments'
                ]
            }
            
        except Exception as e:
            logging.error(f"Error generating executive report: {str(e)}")
            return {'error': str(e)}
    
    def generate_technical_report(self):
        """Generate technical detailed report"""
        try:
            vuln_details = []
            for vuln_id, vuln in self.vulnerabilities.items():
                vuln_details.append({
                    'id': vuln_id,
                    'type': vuln.get('type'),
                    'severity': vuln.get('severity'),
                    'description': vuln.get('description'),
                    'details': vuln.get('details'),
                    'recommendation': vuln.get('recommendation'),
                    'agent_id': vuln.get('agent_id'),
                    'discovered_at': vuln.get('discovered_at')
                })
            
            return {
                'title': 'Technical Vulnerability Assessment Report',
                'vulnerabilities': vuln_details,
                'statistics': {
                    'total_vulnerabilities': len(self.vulnerabilities),
                    'severity_breakdown': dict(self.vulnerability_stats),
                    'vulnerability_types': Counter([v.get('type', 'Unknown') for v in self.vulnerabilities.values()])
                },
                'agents': {
                    'total_agents': len(self.agents),
                    'agent_details': [self.get_agent_summary(agent_id) for agent_id in self.agents.keys()]
                }
            }
            
        except Exception as e:
            logging.error(f"Error generating technical report: {str(e)}")
            return {'error': str(e)}
    
    def generate_comprehensive_report(self):
        """Generate comprehensive report"""
        try:
            executive_summary = self.generate_executive_report()
            technical_details = self.generate_technical_report()
            
            return {
                'title': 'Comprehensive Vulnerability Assessment Report',
                'executive_summary': executive_summary,
                'technical_details': technical_details,
                'dashboard_data': self.dashboard_data,
                'scan_history': list(self.scans.values()),
                'generation_timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            logging.error(f"Error generating comprehensive report: {str(e)}")
            return {'error': str(e)}
    
    def export_report(self, report_id, format='json'):
        """
        Export report in specified format
        
        Args:
            report_id (str): Report ID to export
            format (str): Export format (json, csv, pdf)
            
        Returns:
            dict: Export results
        """
        try:
            if report_id not in self.reports:
                return {
                    'status': 'error',
                    'error': 'Report not found',
                    'timestamp': datetime.now().isoformat()
                }
            
            report = self.reports[report_id]
            
            if format == 'json':
                return {
                    'status': 'success',
                    'format': 'json',
                    'data': report,
                    'timestamp': datetime.now().isoformat()
                }
            elif format == 'csv':
                # Convert to CSV format
                csv_data = self.convert_to_csv(report)
                return {
                    'status': 'success',
                    'format': 'csv',
                    'data': csv_data,
                    'timestamp': datetime.now().isoformat()
                }
            else:
                return {
                    'status': 'error',
                    'error': f'Unsupported format: {format}',
                    'timestamp': datetime.now().isoformat()
                }
                
        except Exception as e:
            logging.error(f"Error exporting report {report_id}: {str(e)}")
            return {
                'status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    def convert_to_csv(self, report):
        """Convert report to CSV format"""
        try:
            # This is a simplified CSV conversion
            # In a real implementation, you'd use a proper CSV library
            csv_lines = []
            
            if 'vulnerabilities' in report:
                csv_lines.append('ID,Type,Severity,Description,Agent ID,Discovered At')
                for vuln in report['vulnerabilities']:
                    csv_lines.append(f"{vuln.get('id', '')},{vuln.get('type', '')},{vuln.get('severity', '')},"
                                   f"{vuln.get('description', '')},{vuln.get('agent_id', '')},{vuln.get('discovered_at', '')}")
            
            return '\n'.join(csv_lines)
            
        except Exception as e:
            logging.error(f"Error converting to CSV: {str(e)}")
            return ""

# Global dashboard instance
dashboard = VulnerabilityDashboard()
